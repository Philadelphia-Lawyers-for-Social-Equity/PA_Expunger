import re

import pytest
from pypdf.errors import PdfReadError

from docket_parser import test_data_path
from docket_parser.extraction import DocketReader, logger as extraction_logger

DATA_PATH = test_data_path
DOCKETS_PATH = DATA_PATH / "dockets"
EXTRACTED_TEXT_PATH = DATA_PATH / "extracted"
MODIFIED_PDFS_PATH = DATA_PATH / "modified_pdfs"


class TestDocketExtraction:
    test_docket_paths = tuple(DOCKETS_PATH.glob("*.pdf"))
    expected_text_paths = tuple(EXTRACTED_TEXT_PATH.glob("*.txt"))

    def test_warn_not_crystal_report(self, caplog):
        """Ensure that there is a logged warning when trying to extract text from a docket not generated by
         Crystal Reports. 'Crystal Reports' should be in that warning message."""
        for modified_pdf in MODIFIED_PDFS_PATH.glob('*.pdf'):
            with caplog.at_level("WARNING", extraction_logger.name):
                DocketReader(modified_pdf)
            assert any("crystal reports" in msg.lower() for msg in caplog.messages), \
                "DocketReader should warn when metadata does not indicate the file is generated by Crystal Reports"

    def test_proper_output_format(self):
        """Check that every line/segment of extracted text has the format expected by the grammar."""
        for test_file_path in self.test_docket_paths:
            reader = DocketReader(test_file_path)
            extracted_text = reader.extract_text()
            lines = extracted_text.split(reader.terminator)
            assert lines[-1] == '', "Extracted text should end with terminator character"

            escaped_close = re.escape(reader.properties_close)
            properties_regex = r"[0-9]{3}\.[0-9]{2},[0-9]{3}\.[0-9]{2},(normal|bold)" + escaped_close
            for line in lines[:-1]:
                split_line = line.split(reader.properties_open)
                assert len(split_line) == 2, \
                    "Reader properties_open character should appear exactly once in each segment"
                content, properties = split_line
                assert reader.properties_close not in content, \
                    "Reader properties_close should not appear before properties_open"

                match = re.match(properties_regex, properties)
                assert len(match.groups()) == 1, "Correctly formatted properties should appear once in each segment."

    def test_error_if_special_char_in_pdf(self):
        """Check that DocketReader throws an error if one of its special characters appears in a PDF it tries to read"""
        original_tab = DocketReader.tab
        test_content_characters = 'ยง aA,.:$/'
        for test_file in self.test_docket_paths:
            for test_content_character in test_content_characters:
                DocketReader.tab = test_content_character
                with pytest.raises(expected_exception=PdfReadError):
                    DocketReader(test_file)

        # This feels very hacky.
        DocketReader.tab = original_tab

    def test_all_dockets(self):
        """Regression test, check that the extracted text from each docket matches known good output."""
        expected_results_dir = DATA_PATH / "extracted"
        expected_result_paths = []
        for test_docket_path in self.test_docket_paths:
            expected_result_filename = test_docket_path.name.replace('.pdf', '.txt')
            expected_result_path = expected_results_dir / expected_result_filename
            expected_result_paths.append(expected_result_path)

        test_expect_pairs = tuple(zip(self.test_docket_paths, expected_result_paths))
        assert len(test_expect_pairs) > 0, "Didn't find any test pdf/txt result pairs"
        for test_docket_path, expected_result_path in test_expect_pairs:
            reader = DocketReader(test_docket_path)
            result = reader.extract_text(test_docket_path)

            with open(expected_result_path, 'r', encoding='utf-8') as expected_result_file:
                expected = expected_result_file.read()

            failure_msg = f"Parsed result from {test_docket_path.name} not equal to expected result" \
                          f" from {expected_result_path.name}"
            # Error messages are currently way too long. Consider finding better way to report string differences?
            assert result == expected, failure_msg
